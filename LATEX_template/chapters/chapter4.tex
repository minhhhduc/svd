\chapter{Thực nghiệm và đánh giá}
\section{Môi trường thực nghiệm}
Các thí nghiệm được thực hiện trên một hệ thống di động sử dụng bộ vi xử lý AMD Ryzen 5 6600HS (Zen 3+, mã hiệu Rembrandt) với thông số kỹ thuật như sau:
\begin{itemize}
    \item Số nhân / luồng: 6 nhân vật lý, 12 luồng xử lý.
    \item Tần số cơ bản / Turbo: 3.3 GHz, lên đến 4.5 GHz.
    \item Bộ nhớ cache: L1 64 KB/cấp nhân, L2 512 KB/cấp nhân, L3 16 MB chia sẻ.
    \item Bộ nhớ: DDR5, tốc độ hiệu dụng 4800 MT/s, kênh đôi, băng thông 76.8 GB/s.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/cpu_info.png}
    \caption{Thông số cpu}
    \label{fig:placeholder}
\end{figure}

\section{Bộ dữ liệu sử dụng}
ma trận được sinh ngẫu nhiên với các kích cỡ khác nhau.

\section{Đánh giá kết quả}

\subsection{Thuật toán nhân ma trận}

\paragraph{Thống kê các thuật toán sau khi chạy với các luồng khác nhau}
\textbf{}
\begin{figure}[H]
    \centering

    % ======= HÀNG 1: 3 ảnh =======
    \begin{minipage}{0.30\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/mulmat_8.png}
        \caption{các phương pháp nhân ma trận dùng 8 thread}
        \label{fig:_8thread}
    \end{minipage}\hfill
    \begin{minipage}{0.30\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/mulmat_9.png}
        \caption{các phương pháp nhân ma trận dùng 9 thread}
        \label{fig:_9thread}
    \end{minipage}\hfill
    \begin{minipage}{0.30\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/mulmat_10.png}
        \caption{các phương pháp nhân ma trận dùng 10 thread}
        \label{fig:_10thread}
    \end{minipage}

    \vspace{0.5cm}

    % ======= HÀNG 2: 2 ảnh =======
    \begin{minipage}{0.32\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/mulmat_11.png}
        \caption{các phương pháp nhân ma trận dùng 11 thread}
        \label{fig:_11thread}
    \end{minipage} \hspace{12pt}
    \begin{minipage}{0.32\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/mulmat_12.png}
        \caption{các phương pháp nhân ma trận dùng 12 thread}
        \label{fig:_12thread}
    \end{minipage}

\end{figure}

\paragraph{Nhận xét:} 
Về tổng quan, thuật toán nhân ma trận cơ bản có thời gian thực thi lâu hơn nhiều so với các thuật toán song song đã được tối ưu hóa (như Cannon, DNS).

Phân tích chi tiết khi thay đổi số luồng từ 8 đến 12:
\begin{itemize}
    \item \textbf{Đối với thuật toán DNS:} Thời gian thực thi không có sự thay đổi đáng kể khi tăng số luồng lên 12. Nguyên nhân là do thuật toán DNS được thiết kế để hoạt động trên mạng lưới vi xử lý lập phương ($p \times p \times p$). Tại 8 luồng ($2^3$), thuật toán hoạt động tối ưu. Tuy nhiên, 12 luồng không phải là lập phương hoàn hảo, dẫn đến việc không tận dụng được thêm tài nguyên tính toán cho cấu trúc đặc thù của DNS.
    \item \textbf{Đối với thuật toán Cannon:} Tại mốc 9 luồng, biểu đồ cho thấy thời gian chạy giảm rõ rệt (nhanh hơn) so với mốc 8 luồng. Điều này được giải thích bởi thuật toán Cannon yêu cầu mạng lưới vi xử lý hình vuông ($p \times p$). Với 9 luồng, ta thiết lập được lưới $3 \times 3$ sử dụng triệt để tài nguyên. Trong khi đó, với 8 luồng, thuật toán chỉ có thể sử dụng lưới $2 \times 2$ (4 luồng), gây lãng phí tài nguyên và hiệu năng thấp hơn.
\end{itemize}

\textbf{Đánh giá về thời gian thực thi song song ($T_{par}$) dựa trên độ phức tạp thuật toán:}

Để giải thích sự thay đổi hiệu năng, ta xem xét độ phức tạp tính toán lý thuyết $O(\frac{n^3}{p_{used}})$ với $p_{used}$ là số luồng thực tế được sử dụng:

\begin{itemize}
    \item \textbf{Tại $p=8$ luồng:}
    \begin{itemize}
        \item \textbf{DNS:} Do $8 = 2^3$, thuật toán tận dụng toàn bộ luồng ($p_{used} = 8$). Độ phức tạp đạt mức tối ưu $O(\frac{n^3}{8})$.
        \item \textbf{Cannon:} Do $8$ không phải số chính phương, thuật toán chỉ sử dụng lưới $2 \times 2$ ($p_{used} = 4$). Độ phức tạp chỉ là $O(\frac{n^3}{4})$.
        \item $\Rightarrow$ DNS nhanh hơn Cannon do $\frac{n^3}{8} < \frac{n^3}{4}$.
    \end{itemize}
    
    \item \textbf{Tại $p=9$ luồng:}
    \begin{itemize}
        \item \textbf{Cannon:} Do $9 = 3^2$, thuật toán tận dụng toàn bộ luồng ($p_{used} = 9$). Độ phức tạp giảm xuống $O(\frac{n^3}{9})$.
        \item \textbf{DNS:} Do $9$ không phải lập phương, thuật toán vẫn chỉ dùng lưới $2 \times 2 \times 2$ ($p_{used} = 8$). Độ phức tạp giữ nguyên $O(\frac{n^3}{8})$.
        \item $\Rightarrow$ Cannon nhanh hơn DNS do $\frac{n^3}{9} < \frac{n^3}{8}$.
    \end{itemize}

    \item \textbf{Tại $p=12$ luồng:}
    \begin{itemize}
        \item \textbf{Cannon:} Vẫn chỉ dùng lưới $3 \times 3$ ($p_{used} = 9$) $\rightarrow O(\frac{n^3}{9})$.
        \item \textbf{DNS:} Vẫn chỉ dùng lưới $2^3$ ($p_{used} = 8$) $\rightarrow O(\frac{n^3}{8})$.
    \end{itemize}
\end{itemize}

\textbf{Kết luận:} 
\begin{itemize}
    \item Hiệu năng thực tế phụ thuộc chặt chẽ vào việc số lượng luồng $p$ có khớp với cấu trúc hình học của thuật toán hay không (lập phương cho DNS, hình vuông cho Cannon).
    \item Mặc dù Broadcast có độ phức tạp tính toán lý thuyết thấp nhất tại $p=12$ ($O(\frac{n^3}{12})$), nhưng chi phí truyền thông cao đã làm giảm hiệu năng tổng thể so với Cannon.
\end{itemize}

\textbf{Đánh giá về hệ số tăng tốc (Speedup):}

Ta định nghĩa hệ số tăng tốc $S = \frac{T_{seq}}{T_{par}}$.

\begin{itemize}
    \item \textbf{Về mặt lý thuyết:} Trong điều kiện lý tưởng, hệ số tăng tốc sẽ tiệm cận với số luồng sử dụng ($S \approx p_{used}$).
    \item \textbf{Về mặt thực nghiệm (với ma trận lớn):}
    \begin{itemize}
        \item \textbf{Thuật toán Cannon ($p=12, p_{used}=9$):} $S_{exp} \approx \frac{34s}{3s} \approx 11.3$. Kết quả này cao hơn cả lý thuyết ($S_{theory} = 9$). Hiện tượng "tăng tốc siêu tuyến tính" (super-linear speedup) này xảy ra do thuật toán Cannon sử dụng kỹ thuật chia khối (blocking), giúp tận dụng bộ nhớ cache (L1/L2) hiệu quả hơn nhiều so với thuật toán nhân ma trận tuần tự thông thường (thường bị cache miss lớn với ma trận kích thước lớn).
        \item \textbf{Thuật toán DNS ($p=12, p_{used}=8$):} $S_{exp} \approx \frac{34s}{4s} \approx 8.5$. Đạt hiệu suất rất tốt, xấp xỉ hoặc nhỉnh hơn lý thuyết ($S_{theory} = 8$).
    \end{itemize}
\end{itemize}

\subsection{Thuật toán biến thể giảm chuẩn Jacobi để tính giá trị riêng}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/eigen_compare.png}
    \caption{Biểu đồ thể hiên tốc độ chạy của thuật toán giảm chuẩn với ma trận thực khi song song và chưa song song}
    \label{fig:placeholder}
\end{figure}

\paragraph{Nhận xét:}
Dựa trên kết quả thực nghiệm, ta có thể thấy rõ sự khác biệt về hiệu năng giữa thuật toán tuần tự và song song phụ thuộc vào kích thước ma trận:
\begin{itemize}
    \item \textbf{Với các ma trận kích thước nhỏ ($N < 256$):} Thuật toán tuần tự cho thời gian thực thi nhanh hơn. Nguyên nhân là do chi phí khởi tạo luồng (thread overhead) và đồng bộ hóa trong phiên bản song song lớn hơn so với khối lượng tính toán thực tế, dẫn đến hiệu suất thấp hơn.
    \item \textbf{Với các ma trận kích thước lớn ($N \ge 256$):} Thuật toán song song bắt đầu thể hiện ưu thế vượt trội. Tại kích thước $N=512$, phiên bản song song nhanh hơn khoảng 3 lần, và tại $N=1024$, tốc độ nhanh hơn khoảng 4.4 lần so với tuần tự. Điều này chứng minh khả năng mở rộng tốt của thuật toán song song khi khối lượng tính toán đủ lớn để bù đắp chi phí quản lý luồng.
\end{itemize}

\textbf{Đánh giá về hệ số tăng tốc (Speedup):}
\begin{itemize}
    \item Tại $N=1024$, hệ số tăng tốc đạt $S \approx 4.4$. Mặc dù thấp hơn số luồng lý thuyết (12 luồng), nhưng đây là kết quả chấp nhận được đối với thuật toán Jacobi.
    \item Nguyên nhân $S < p_{used}$ là do thuật toán Jacobi đòi hỏi sự đồng bộ hóa (synchronization) liên tục sau mỗi vòng lặp quét (sweep) để cập nhật ma trận. Chi phí giao tiếp và đồng bộ này làm giảm hiệu suất song song tổng thể.
\end{itemize}

\subsection{Thuật toán khác}
\subsubsection{Sắp xếp mảng (Argsort)}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/compare_argsort.png}
    \caption{Biểu đồ thể hiện tốc độ chạy của thuật toán sắp xếp theo kích thước của mảng với số luồng chạy khác nhau}
    \label{fig:argsort_compare}
\end{figure}

\paragraph{Nhận xét:}
\begin{itemize}
    \item \textbf{Hệ số tăng tốc:} Với mảng kích thước lớn ($\approx 9.6 \times 10^6$ phần tử), thuật toán đạt hệ số tăng tốc tối đa khoảng $4.4$ lần ($2.2s$ xuống $0.5s$).
    \item \textbf{Điểm bão hòa:} Hiệu năng bắt đầu bão hòa tại khoảng \textbf{8 luồng}. Việc tăng lên 12 luồng không mang lại cải thiện đáng kể (thời gian giữ nguyên ở mức $\approx 0.5s$).
    \item \textbf{Lý do:} Thuật toán sắp xếp song song thường bị giới hạn bởi băng thông bộ nhớ (memory bandwidth bound) khi hợp nhất các mảng con và chi phí quản lý luồng khi kích thước mảng con trở nên nhỏ.
\end{itemize}

\subsubsection{Chuyển vị ma trận}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/tranpose_compare.png}
    \caption{Biểu đồ thể hiện tốc độ chạy của chuyển vị ma trận theo kích thước của ma trận với số luồng chạy khác nhau}
    \label{fig:tranpose_matrix}
\end{figure}

\paragraph{Nhận xét:}
\begin{itemize}
    \item \textbf{Hệ số tăng tốc:} Đạt khoảng $5$ lần ($0.1s$ xuống $0.02s$).
    \item \textbf{Điểm bão hòa:} Bão hòa rất sớm, tại khoảng \textbf{6 luồng}.
    \item \textbf{Lý do:} Chuyển vị ma trận là thao tác thuần túy về truy cập bộ nhớ (memory-bound), ít tính toán. Khi số luồng tăng lên, băng thông bộ nhớ của hệ thống nhanh chóng bị bão hòa, khiến việc thêm luồng không giúp xử lý nhanh hơn.
\end{itemize}

\subsubsection{Lấy căn bậc 2 của 1 mảng}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/square_compare.png}
    \caption{Biểu đồ thể hiện tốc độ chạy của thuật toán lấy căn bậc 2 của 1 mảng theo số kích thước của mảng với số luồng chạy khác nhau}
    \label{fig:square_array}
\end{figure}

\paragraph{Nhận xét:}
\begin{itemize}
    \item \textbf{Hệ số tăng tốc:} Đạt khoảng $3.8$ lần ($0.027s$ xuống $0.007s$).
    \item \textbf{Điểm bão hòa:} Bão hòa tại khoảng \textbf{6-8 luồng}.
    \item \textbf{Lý do:} Tương tự như chuyển vị, đây là thao tác đơn giản trên từng phần tử. Thời gian thực thi quá nhanh khiến chi phí khởi tạo luồng chiếm tỷ trọng lớn, và băng thông bộ nhớ cũng trở thành nút thắt cổ chai.
\end{itemize}

\subsection{Thuật toán giảm chiều dữ liệu (SVD Decomposition)}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/compare_SVD.png}
    \caption{Biểu đồ so sánh thời gian thực thi SVD giữa tuần tự và song song}
    \label{fig:svd_compare}
\end{figure}

\paragraph{Nhận xét:}
Dựa trên bảng số liệu thực nghiệm (file \texttt{decompose.csv}), ta có những đánh giá sau:

\begin{itemize}
    \item \textbf{Với dữ liệu nhỏ ($N < 500$):}
    \begin{itemize}
        \item Thuật toán tuần tự hoạt động hiệu quả hơn hẳn. Ví dụ với ma trận $490 \times 64$, tuần tự mất $0.068s$ trong khi song song mất tới $0.367s$ (chậm hơn $\approx 5$ lần).
        \item \textbf{Lý do:} Chi phí khởi tạo luồng và quản lý vùng song song (OpenMP overhead) lớn hơn nhiều so với thời gian tính toán thực tế của bài toán nhỏ.
    \end{itemize}

    \item \textbf{Với dữ liệu trung bình ($N \approx 750$):}
    \begin{itemize}
        \item Thuật toán song song bắt đầu vượt lên. Tại kích thước $750 \times 512$, thời gian giảm từ $15.6s$ (tuần tự) xuống còn $5.8s$ (song song).
        \item \textbf{Hệ số tăng tốc:} $S \approx 2.7$ lần.
    \end{itemize}

    \item \textbf{Với dữ liệu lớn ($N > 3000$):}
    \begin{itemize}
        \item Hiệu quả song song hóa đạt mức cao nhất. Với ma trận $3333 \times 768$, thời gian giảm mạnh từ $71.3s$ xuống còn $15.6s$.
        \item \textbf{Hệ số tăng tốc:} $S \approx \frac{71.3}{15.6} \approx 4.6$ lần.
        \item \textbf{Kết luận:} Thuật toán SVD song song chỉ thực sự phát huy tác dụng với các bộ dữ liệu lớn, nơi khối lượng tính toán đủ lớn để che lấp chi phí quản lý luồng.
    \end{itemize}
\end{itemize}
